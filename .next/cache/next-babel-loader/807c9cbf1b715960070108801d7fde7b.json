{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React from 'react';\nimport List from 'macoolka-ui-components/lib/List';\nimport Divider from 'macoolka-ui-components/lib/Divider';\nimport AppDrawerNavItem from './AppDrawerNavItem';\nimport { makeStyles } from '@material-ui/core/styles';\nimport AppTitle from './AppTitle';\nimport { parseStandProp } from 'macoolka-ui-core';\nimport SideBar from './Sidebar';\nimport { useAppStyle, useNavItems } from '../AppContext'; //import { QueryCategories } from '../../schema/ggl'\n\nvar savedScrollTop = undefined;\n\nvar PersistScroll = function PersistScroll(_ref) {\n  var children = _ref.children;\n  var rootRef = React.useRef(null);\n  React.useEffect(function () {\n    var parent = rootRef.current ? rootRef.current.parentElement : null;\n    var activeElement = document.querySelector('.drawer-active');\n\n    if (!parent || !activeElement || !activeElement.scrollIntoView) {\n      return undefined;\n    }\n\n    var activeBox = activeElement.getBoundingClientRect();\n\n    if (savedScrollTop !== null || activeBox.top < savedScrollTop) {\n      // Center the selected item in the list container.\n      activeElement.scrollIntoView(); // Fix a Chrome issue, reset the tabbable ring back to the top of the document.\n\n      document.body.scrollIntoView();\n    } else {\n      parent.scrollTop = savedScrollTop;\n    }\n\n    return function () {\n      savedScrollTop = parent.scrollTop;\n    };\n  }, []);\n  return __jsx(\"div\", {\n    ref: rootRef\n  }, children);\n};\n\nvar useStyles = makeStyles(function (theme) {\n  return {\n    appNav: _objectSpread({}, parseStandProp(theme)({\n      mkScrollBar: \"vertical\",\n      height: 'calc(100vh - 75px)'\n    })),\n    root: _objectSpread({}, parseStandProp(theme)({\n      color: theme.app.appNav.color,\n      backgroundColor: theme.app.appNav.backgroundColor\n    })),\n    divider: {\n      background: theme.app.appNavDivider.backgroundColor\n    }\n  };\n});\n\nvar NavItem = function NavItem(_ref2) {\n  var data = _ref2.data,\n      depth = _ref2.depth,\n      props = _ref2.props;\n  var title = data.title;\n  /*   if (page.forest.length > 0) {\n           const topLevel = isNone(activePage) ? false : activePage.value.id.indexOf(`${page.value.id}`) === 0;\n        return <AppDrawerNavItem\n            // linkProps={page.linkProps}\n            depth={depth}\n            key={title}\n            topLevel={topLevel}\n            openImmediately={topLevel}\n            title={title}\n        >\n            <List>\n                {page.forest.map(a =>\n                    <NavItem key={a.value.id} page={a} activePage={activePage} depth={depth + 1} props={props}{...params}></NavItem>\n                   )}\n            </List>\n   \n        </AppDrawerNavItem>\n       } else { */\n\n  return __jsx(AppDrawerNavItem //linkProps={page.linkProps}\n  , {\n    depth: depth,\n    key: title,\n    data: data\n  });\n  /*    href='/[id]'\n     as={`/${page.id}`} */\n  //   onClick={props.onClose}\n}; // iOS is hosted on high-end devices. We can enable the backdrop transition without\n// dropping frames. The performance will be good enough.\n// So: <SwipeableDrawer disableBackdropTransition={false} />\n//const iOS = (process as any).browser && /iPad|iPhone|iPod/.test(navigator.userAgent);\n\n\nvar AppDrawer = function AppDrawer(props) {\n  var _useAppStyle = useAppStyle(),\n      toggleExpandNav = _useAppStyle.toggleExpandNav,\n      isOpenExpandNav = _useAppStyle.isOpenExpandNav;\n\n  var classes = useStyles();\n  var navItems = useNavItems();\n  return __jsx(SideBar, {\n    open: isOpenExpandNav,\n    handleDrawerToggle: function handleDrawerToggle() {\n      return toggleExpandNav({});\n    },\n    rtlActive: false\n  }, __jsx(\"div\", {\n    className: classes.root\n  }, __jsx(AppTitle, null), __jsx(Divider, {\n    className: classes.divider\n  }), __jsx(PersistScroll, null, __jsx(List, {\n    className: classes.appNav\n  }, navItems.map(function (a) {\n    return __jsx(NavItem, {\n      key: a.id,\n      data: a,\n      depth: 0,\n      props: props\n    });\n  })))));\n};\n\nexport default AppDrawer;","map":null,"metadata":{},"sourceType":"module"}