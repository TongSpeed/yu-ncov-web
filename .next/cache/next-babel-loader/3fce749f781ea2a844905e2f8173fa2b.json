{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from 'react';\nimport List from 'macoolka-ui-components/lib/List';\nimport Divider from 'macoolka-ui-components/lib/Divider';\nimport AppDrawerNavItem from './AppDrawerNavItem';\nimport { makeStyles } from '@material-ui/core/styles';\nimport AppTitle from './AppTitle';\nimport { parseStandProp } from 'macoolka-ui-core';\nimport SideBar from './Sidebar';\nimport { useAppStyle, useNavItems } from '../AppContext'; //import { QueryCategories } from '../../schema/ggl'\n\nlet savedScrollTop = undefined;\n\nconst PersistScroll = ({\n  children\n}) => {\n  const rootRef = React.useRef(null);\n  React.useEffect(() => {\n    const parent = rootRef.current ? rootRef.current.parentElement : null;\n    const activeElement = document.querySelector('.drawer-active');\n\n    if (!parent || !activeElement || !activeElement.scrollIntoView) {\n      return undefined;\n    }\n\n    const activeBox = activeElement.getBoundingClientRect();\n\n    if (savedScrollTop !== null || activeBox.top < savedScrollTop) {\n      // Center the selected item in the list container.\n      activeElement.scrollIntoView(); // Fix a Chrome issue, reset the tabbable ring back to the top of the document.\n\n      document.body.scrollIntoView();\n    } else {\n      parent.scrollTop = savedScrollTop;\n    }\n\n    return () => {\n      savedScrollTop = parent.scrollTop;\n    };\n  }, []);\n  return __jsx(\"div\", {\n    ref: rootRef\n  }, children);\n};\n\nconst useStyles = makeStyles(theme => {\n  return {\n    appNav: _objectSpread({}, parseStandProp(theme)({\n      mkScrollBar: \"vertical\",\n      height: 'calc(100vh - 75px)'\n    })),\n    root: _objectSpread({}, parseStandProp(theme)({\n      color: theme.app.appNav.color,\n      backgroundColor: theme.app.appNav.backgroundColor\n    })),\n    divider: {\n      background: theme.app.appNavDivider.backgroundColor\n    }\n  };\n});\n\nconst NavItem = ({\n  data,\n  depth,\n  props\n}) => {\n  const title = data.title;\n  /*   if (page.forest.length > 0) {\n           const topLevel = isNone(activePage) ? false : activePage.value.id.indexOf(`${page.value.id}`) === 0;\n        return <AppDrawerNavItem\n            // linkProps={page.linkProps}\n            depth={depth}\n            key={title}\n            topLevel={topLevel}\n            openImmediately={topLevel}\n            title={title}\n        >\n            <List>\n                {page.forest.map(a =>\n                    <NavItem key={a.value.id} page={a} activePage={activePage} depth={depth + 1} props={props}{...params}></NavItem>\n                   )}\n            </List>\n   \n        </AppDrawerNavItem>\n       } else { */\n\n  return __jsx(AppDrawerNavItem //linkProps={page.linkProps}\n  , {\n    depth: depth,\n    key: title,\n    data: data\n  });\n  /*    href='/[id]'\n     as={`/${page.id}`} */\n  //   onClick={props.onClose}\n}; // iOS is hosted on high-end devices. We can enable the backdrop transition without\n// dropping frames. The performance will be good enough.\n// So: <SwipeableDrawer disableBackdropTransition={false} />\n//const iOS = (process as any).browser && /iPad|iPhone|iPod/.test(navigator.userAgent);\n\n\nconst AppDrawer = props => {\n  const {\n    toggleExpandNav,\n    isOpenExpandNav\n  } = useAppStyle();\n  const classes = useStyles();\n  const navItems = useNavItems();\n  return __jsx(SideBar, {\n    open: isOpenExpandNav,\n    handleDrawerToggle: () => toggleExpandNav({}),\n    rtlActive: false\n  }, __jsx(\"div\", {\n    className: classes.root\n  }, __jsx(AppTitle, null), __jsx(Divider, {\n    className: classes.divider\n  }), __jsx(PersistScroll, null, __jsx(List, {\n    className: classes.appNav\n  }, navItems.map(a => __jsx(NavItem, {\n    key: a.id,\n    data: a,\n    depth: 0,\n    props: props\n  }))))));\n};\n\nexport default AppDrawer;","map":null,"metadata":{},"sourceType":"module"}